// Generated by CoffeeScript 1.6.3
var fs, path,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

module.exports = function(grunt) {
  var UnwatchableFileOptions, addDefaultWatchTargetProperties, apply, collectTargetFiles, combineFileLists, description, getCompactFormatSourceFiles, getFileObjectSourceFileLists, getTaskFileLists, getWatchTargetFileList, identifyFileObjectFormat, isFileObject, isValidMultiTaskTarget, _;
  _ = grunt.util._;
  description = grunt.file.readJSON(path.join(path.dirname(module.filename), '../package.json')).description;
  isValidMultiTaskTarget = function(target) {
    return !/^_|^options$/.test(target);
  };
  isFileObject = function(data) {
    if (!data) {
      return false;
    }
    return Boolean(identifyFileObjectFormat(data));
  };
  identifyFileObjectFormat = function(data) {
    switch (false) {
      case !_.isString(data):
        return "String";
      case !('src' in data):
        return "Compact";
      case grunt.util.kindOf(data.files) !== 'object':
        return "File Object";
      case !_.isArray(data.files):
        return "Files Array";
      default:
        return null;
    }
  };
  getFileObjectSourceFileLists = function(data) {
    var format, sourceFileExtractors;
    sourceFileExtractors = {
      "String": function() {
        return [[data]];
      },
      "Compact": function() {
        return [getCompactFormatSourceFiles(data)];
      },
      "File Object": function() {
        return [_.values(data.files)];
      },
      "Files Array": function() {
        return data.files.map(getCompactFormatSourceFiles);
      }
    };
    format = identifyFileObjectFormat(data);
    if (!format) {
      grunt.log.error("Unrecognized file spec " + data);
    }
    return (typeof sourceFileExtractors[format] === "function" ? sourceFileExtractors[format](format) : void 0) || [];
  };
  UnwatchableFileOptions = ['dot', 'matchBase', 'nocase', 'nobrace', 'noglobstar', 'noext', 'nocomment', 'nonegate', 'flipnegate'];
  getCompactFormatSourceFiles = function(data) {
    var files, illegalOptions, pl, prependDirectory, ser;
    illegalOptions = UnwatchableFileOptions.filter(function(option) {
      return data[option];
    });
    if (illegalOptions.length) {
      ser = function(items) {
        var butLast, last;
        butLast = items.slice();
        last = butLast.pop();
        if (!butLast.length) {
          return last;
        }
        return [butLast.join(', '), last].join(', and '.slice(butLast.length === 1));
      };
      pl = function(base, count) {
        return "" + base + ('s'.slice(count === 1));
      };
      grunt.log.error("Watch cannot proceess the " + (ser(illegalOptions)) + " " + (pl('option', illegalOptions.length)));
      return [];
    }
    files = data.src;
    if (!_.isArray(data.src)) {
      files = [files];
    }
    prependDirectory = function(cwd) {
      return function(pattern) {
        var file, negation, __, _ref;
        _ref = pattern.match(/(!?)(.*)/), __ = _ref[0], negation = _ref[1], file = _ref[2];
        return [negation, file.match(/^\//) ? file : path.join(data.cwd, file)].join('');
      };
    };
    if (data.cwd) {
      files = files.map(prependDirectory(data.cwd));
    }
    return files;
  };
  combineFileLists = function(fileLists) {
    var isNegativePattern, list, negativePatternsInAllLists, negativePatternsPerFileList;
    isNegativePattern = function(pathname) {
      return /^!/.test(pathname);
    };
    negativePatternsPerFileList = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = fileLists.length; _i < _len; _i++) {
        list = fileLists[_i];
        _results.push(list.filter(isNegativePattern));
      }
      return _results;
    })();
    negativePatternsInAllLists = _.chain(negativePatternsPerFileList).flatten(true).select(function(n) {
      return negativePatternsPerFileList.every(function(l) {
        return __indexOf.call(l, n) >= 0;
      });
    }).uniq().value();
    return _.chain(fileLists).flatten().reject(isNegativePattern).uniq().union(negativePatternsInAllLists).value();
  };
  collectTargetFiles = function(data) {
    return _.chain(data).keys().filter(isValidMultiTaskTarget).map(function(target) {
      return data[target];
    }).filter(isFileObject);
  };
  getTaskFileLists = function(task) {
    var data, target, _ref;
    _ref = task.split(':', 2), task = _ref[0], target = _ref[1];
    if (target === '*') {
      target = null;
    }
    data = grunt.config.get(_.compact([task, target]));
    if (isFileObject(data)) {
      return getFileObjectSourceFileLists(data);
    }
    if (target) {
      return [];
    }
    return _.chain(data).keys().filter(isValidMultiTaskTarget).map(function(target) {
      return data[target];
    }).filter(isFileObject).map(getFileObjectSourceFileLists).flatten(true).value();
  };
  getWatchTargetFileList = function(target, data) {
    var fileLists, task;
    fileLists = _.flatten((function() {
      var _i, _len, _ref, _results;
      _ref = data.tasks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        task = _ref[_i];
        _results.push(getTaskFileLists(task));
      }
      return _results;
    })(), true);
    if (!fileLists.length) {
      grunt.log.warn("The tasks in watch." + target + ".tasks do not specify any files");
    }
    return combineFileLists(fileLists);
  };
  addDefaultWatchTargetProperties = function(target, cfg) {
    if (cfg.tasks == null) {
      cfg.tasks = [target];
    }
    return cfg.files != null ? cfg.files : cfg.files = getWatchTargetFileList(target, cfg);
  };
  apply = function(options) {
    var cfg, cfgPath, target, task, watchTaskName, _i, _j, _len, _len1, _ref, _ref1, _results;
    watchTaskName = 'watch';
    _ref = options.tasks || [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      task = _ref[_i];
      cfgPath = [watchTaskName, task];
      cfg = grunt.config.getRaw(cfgPath) || {};
      if (cfg.tasks) {
        grunt.log.warn("" + (cfgPath.join('.')) + " already has a \"tasks\" property");
      }
      if (cfg.tasks == null) {
        cfg.tasks = [task];
      }
      grunt.config.set(cfgPath, cfg);
    }
    _ref1 = _.keys(grunt.config.getRaw(watchTaskName)).filter(isValidMultiTaskTarget);
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      target = _ref1[_j];
      cfgPath = [watchTaskName, target];
      cfg = grunt.config.get(cfgPath);
      addDefaultWatchTargetProperties(target, cfg);
      _results.push(grunt.config.set(cfgPath, cfg));
    }
    return _results;
  };
  return grunt.registerTask('autowatch', description, function() {
    var options;
    options = _.extend({
      run: true
    }, grunt.config([this.name, 'options']) || {});
    grunt.util.hooker.hook(grunt.task, 'run', function(task) {
      if (task === 'watch') {
        return apply(options);
      }
    });
    apply(options);
    if (options.run && this.errorCount === 0) {
      grunt.task.run('watch');
    }
    return this.errorCount === 0;
  });
};

/*
//@ sourceMappingURL=autowatch.map
*/
